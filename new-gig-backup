#!/usr/bin/env ruby
# Description:  Simple EC2 backup script for EBS based instances
# Author:       Sergey Zhuga <sergey.zhuga@gigware.com>

require 'logger'

require 'rubygems'
require 'right_aws'
begin
  gem 'right_aws', '2.1.0'
rescue Gem::LoadError => e
  puts e.message
  exit 1
end


### Config Variables
AWS_ACCESS_KEY =        'AKIAI3WG5PTF5NKXZLIA'
AWS_SECRET_ACCESS_KEY = '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'
BACKUP_TAG =            'gig-backup'
LOG_FILE  =             'backup.log'
#snapshots_to_remove =   []
SOURCE_REGION =         'us-east-1'
TARGET_REGIONS =        %w{'us-west-2'}

# Parse command-line arguments
if ARGV
  ARGV.each do |argument|
    case argument
      when '--help': usage
      when /--log-file=(.*)/: LOG_FILE = argument.sub('--log-file=', '')

      when '--verbose': log_file = STDOUT
      else puts "Unknown argument #{argument}. Use '--help'."; exit 1
    end
  end
end

# Usage
def usage
  puts 'Usage: gig-backup [options]'
  puts 'Options:'

  puts "  --help\t\t- this message"
  puts "  --log-file=LOG_FILE\t- write log to LOG_FILE"
  puts "  --verbose\t\t- verbose mode (overrides '--log-file' argument)"
  exit 0
end

def setup_logger
  log = Logger.new(LOG_FILE, 'weekly')
  log.level = Logger::INFO
end

def start
  @snapshots_to_remove = []
  @amis_to_migrate = []
  current_date = Time.now.strftime('%Y-%m-%d')
  @ec2 = RightAws::Ec2.new(aws_access_key_id, aws_secret_access_key, {:logger => log, :connections => :dedicated})
  instances = @ec2.describe_instances

  instances.each do |instance|
    # Check backup tag
    if instance[:tags][backup_tag].to_i != 0 && instance[:aws_state] == 'running'
      number_of_images = instance[:tags][backup_tag].to_i - 1


    # Generate new AMI name
    # AMI names must be between 3 and 128 characters long, and may contain letters, numbers, '(', ')', '.', '-', ' ' and '_'
    if instance[:tags]['Name']
      instance_name = instance[:tags]['Name'].gsub(/[^A-Za-z0-9\(\)\.\-\_\ ]/, '').slice(0..127)
    else
      instance_name = instance[:aws_instance_id]
    end
    ami_name = instance_name + '/' + current_date


    # Generate new AMI description
    ami_description = backup_tag + '; '
    ami_description += 'AZ:'     + instance[:aws_availability_zone] + '; '
    ami_description += 'TYPE:'   + instance[:aws_instance_type] + '; '

    ami_description += 'IP:'     + instance[:ip_address] + '; '
    ami_description += 'KEY:'    + instance[:ssh_key_name] + '; '
    ami_description += 'GROUPS:' + instance[:aws_groups].join(',')


    # Create new AMI
    log.info "Proceed instance #{instance_name}."
    ami_id = @ec2.create_image(instance[:aws_instance_id], :name => ami_name, :description => ami_description.slice(0..254), :no_reboot => true)


    # Cleanup if backup was successful
    if ami_id
      @amis_to_migrate << ami_id
      log.info "AMI #{ami_name} created successfuly. ID: #{ami_id}."
      # Search images date cretion for current instance

      images = @ec2.describe_images_by_owner(instance[:aws_owner])
      images_date = []
      images.each do |image|
        # Select date of each image creation
        if (image[:root_device_type] == 'ebs') &&

           (image[:name].split('/').first == instance_name) &&
           (image[:description].split(';').first == backup_tag)
          images_date << image[:name].split('/').last

        end
      end

      # Sort and cut images date
      images_date.sort!
      images_date.delete(current_date)
      log.info "Old AMIs of instance #{instance_name}: #{images_date.inspect}."


      number_of_images_to_remove = images_date.length - number_of_images
      if number_of_images_to_remove > 0
        log.info "#{number_of_images_to_remove} AMIs should be removed."


        # Deregister old AMIs
        images.each do |image|
          # If AMI creation date in dates to remove list
          if (image[:name].split('/').first == instance_name) &&
             (image[:description].split(';').first == backup_tag) &&

             (images_date[0...number_of_images_to_remove].include?(image[:name].split('/').last))
            # Deregister the AMI
            if @ec2.deregister_image(image[:aws_id])
              log.info "AMI #{image[:name]} deregistered. ID: #{image[:aws_id]}."

              # And delete all its snapshots
              image[:block_device_mappings].each do |snapshot|
                log.info "Snapshot of AMI #{image[:name]} will be removed by cleanup. ID: #{snapshot[:ebs_snapshot_id]}."
                snapshots_to_remove << snapshot[:ebs_snapshot_id]
              end
            else
              log.error "Can't deregister AMI #{image[:name]}. ID: #{image[:aws_id]}."
            end

          end
        end
      end
    else
      log.error "Can't create AMI of #{instance_name} instance."
    end
  end
end

# Cleanup
sleep 10
log.info "Cleanup started."

snapshots_to_remove.each do |snapshot|
  if @ec2.delete_snapshot(snapshot)
    log.info "Snapshot #{snapshot} removed."
  else
    log.error "Can't remove the snapshot #{snapshot}."

  end
end

def create_amis
end
